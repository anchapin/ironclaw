# Holon: No-Dependency Minimal Structure

**ID**: no-deps-minimal-1739116783000
**Level**: L0 (Hypothesis) ❌ NOT PROMOTED
**Kind**: system
**Decision Context**: project-structure-decision-1739116780000
**Created**: 2025-02-09
**Verified**: 2025-02-09

## Content

### Method (Recipe)
Extreme minimal structure with zero external tooling dependencies:

```
ironclaw/
├── orchestrator/
│   ├── main.rs             # Single-file CLI (initially)
│   └── vm.rs               # Single-file VM module
├── agent/
│   ├── loop.py             # Single-file reasoning loop
│   └── test_loop.py        # Single-file test
├── .gitignore
├── LICENSE
└── README.md
```

**No Build Tools Initially**:
- Rust: Direct `rustc` compilation (no Cargo until needed)
- Python: Direct `python loop.py` (no pyproject.toml until needed)
- Tests: Single `test_*.py` file with asserts (no pytest initially)
- Git: Hand-written `.gitignore` (no pre-commit hooks)

**Add Tooling Only When Pain is Felt**:
- Add Cargo when we have >3 Rust files
- Add pytest when we have >5 tests
- Add pre-commit when team size >2
- Add CI when we have external contributors

**TDD Philosophy**:
- Write test function next to implementation
- Run `python test_loop.py` manually
- Run `rustc --test` manually
- Commit when test passes

## Scope
**Applies to**: Proof-of-concept phase, solo developer, rapid prototyping
**Languages**: Rust (bare minimum), Python 3.11+ (stdlib only)
**Constraints**: Zero external dependencies until proven necessary

## Verification Report

### Type Check (C.3 Kind-CAL)
**Status**: ✅ PASSED

**Rationale**: Hypothesis kind is `system` (architectural decision). The minimal structure is technically valid for early prototyping.

### Constraint Check
**Status**: ❌ FAILED (Violates Invariants #9, #10)

**Security Invariants (#1-4)**:
- ⚠️ **#1 Zero Host Execution**: Structure does not prevent host execution during development (developer might accidentally run on host)
- ✅ **#2-4**: Not directly violated, but lack of CI makes enforcement difficult

**Architecture Invariants (#5-8)**:
- ⚠️ **#5 Rust/Python Split**: Structure supports split, but no build tooling ensures correctness
- ❌ **#7 Startup Performance**: No automated way to measure <500ms target (manual benchmarking only)
- ❌ **#8 Memory Efficiency**: No automated way to enforce <100MB baseline

**Code Quality Invariants (#9-12)**:
- ❌ **#9 Auditability**: NO ENFORCEMENT of 4,000 LOC limit on `loop.py`. Manual checking only. **CRITICAL VIOLATION**
- ❌ **#10 Determinism**: "Vibe coding" is encouraged by lack of automated guards (no pre-commit hooks, no CI)
- ✅ **#11 Standardization**: Uses stdlib only (aligns with standardization)
- ✅ **#12 Zero Manual Containers**: No containers used

**Operational Invariants (#13-15)**:
- ✅ **#13 Local-First**: No cloud dependencies
- ✅ **#14 Private Mesh**: Can add later
- ✅ **#15 Rust GUI**: Can add later

### Logical Consistency
**Status**: ❌ FAILED

**Analysis**:
1. **TDD Support**: Manual test execution (no automated runner) violates TDD principle of rapid feedback ❌
2. **LOC Enforcement**: "Add pytest when >5 tests" means NO automated LOC checking until code is already bloated ❌
3. **Performance Validation**: Manual benchmarking is insufficient for <500ms requirement (easy to fudge numbers) ❌
4. **Security Testing**: No CI means security checks are optional (developer can skip them) ❌

**Method → Outcome Mapping**:
- Claim: "Forces simplicity" → Evidence: True initially, but technical debt accrues rapidly ⚠️
- Claim: "Aligns with minimal, auditable principles" → Evidence: False—no automated LOC checking makes auditability impossible ❌
- Claim: "Zero setup time" → Evidence: True, but at cost of long-term maintainability ⚠️

### Critical Failure Points
1. **Invariant #9 Violation**: Cannot enforce 4,000 LOC limit without CI/manual checking is unreliable
2. **Invariant #10 Violation**: Lack of pre-commit hooks encourages "vibe coding" (the very thing IronClaw opposes)
3. **Refactoring Pain**: Converting from no-Cargo to Cargo later is HIGHLY disruptive (file moves, build config changes)
4. **No Safety Nets**: Solo developer can accidentally violate invariants without any automated feedback

### When This Approach Might Work
- Proof-of-concept for a single feature (not entire project)
- Exploring a specific technical question (e.g., "Can we use Firecracker?")
- Should be DISCARDED before writing production code

## Rationale
```json
{
  "anomaly": "Modern development tools add complexity before it's needed",
  "approach": "Start with absolute minimum, add tools incrementally when pain is felt",
  "alternatives_rejected": [
    "Full CI/CD from day 1 (overengineering for 0 contributors)",
    "Pre-commit hooks for solo dev (adds friction to experimentation)",
    "Complex workspaces for <1000 LOC codebase (premature abstraction)"
  ],
  "confidence_drivers": [
    "Forces understanding of fundamentals (no cargo-culting)",
    "Zero setup time (clone and run)",
    "Tooling learns from project needs, not vice versa",
    "Aligns with 'Agentic Engineering' principle (minimalism)"
  ]
}
```

## Relations
- **MemberOf**: project-structure-decision-1739116780000
- **DependsOn**: []

## Advantages
✅ **Zero Setup**: Clone repository, run code immediately
✅ **Forces Simplicity**: No tooling means code must stay simple
✅ **True Understanding**: Learn why tools are needed before adopting them
✅ **Rapid Prototyping**: No fighting with build configs during exploration
✅ **Philosophically Aligned**: Matches "minimal, auditable" IronClaw principles

## Disadvantages
❌ **Scaling Pain**: Adding Cargo/pyproject.toml later is disruptive
❌ **No Safety Nets**: No pre-commit hooks, no CI, easy to break code
❌ **Manual Testing**: No automated test runner initially
❌ **Team Onboarding**: Future contributors must learn "non-standard" structure
❌ **Reinstrumenting**: Adding tools later feels like "catch-up" work

## Dependencies
None (foundational hypothesis)

## Metadata
- **Author**: FPF Phase 1 (Abduction)
- **Verified By**: FPF Phase 2 (Deduction)
- **Category**: Radical (rejects modern dev tooling orthodoxy)
- **Complexity**: Low (initially), Medium (reinstrumenting later)
- **Risk**: High (technical debt accrues rapidly)
- **Verdict**: ❌ **FAIL** - NOT promoted to L1
- **Failure Reason**: Violates Invariants #9 (no LOC enforcement) and #10 (encourages vibe coding)
- **Recommendation**: Use for proof-of-concept ONLY, then migrate to L1 hypothesis before production
